// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package queries

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (
    title,
    slug,
    summary,
    description,
    location_id,
    contract_type,
    work_pattern,
    salary_min,
    salary_max,
    currency,
    status,
    source,
    source_ref,
    posted_at,
    expires_at
) VALUES (
    $1,
    $2,
    $3::text,
    $4,
    $5::bigint,
    $6::text,
    $7::text,
    $8::integer,
    $9::integer,
    $10::text,
    COALESCE($11::text, 'draft'),
    $12::text,
    $13::text,
    $14::timestamptz,
    $15::timestamptz
)
RETURNING id, title, slug, summary, description, location_id, contract_type, work_pattern, salary_min, salary_max, currency, status, source, source_ref, posted_at, expires_at, created_at, updated_at
`

type CreateJobParams struct {
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Summary      sql.NullString `json:"summary"`
	Description  string         `json:"description"`
	LocationID   sql.NullInt64  `json:"location_id"`
	ContractType sql.NullString `json:"contract_type"`
	WorkPattern  sql.NullString `json:"work_pattern"`
	SalaryMin    sql.NullInt32  `json:"salary_min"`
	SalaryMax    sql.NullInt32  `json:"salary_max"`
	Currency     sql.NullString `json:"currency"`
	Status       sql.NullString `json:"status"`
	Source       sql.NullString `json:"source"`
	SourceRef    sql.NullString `json:"source_ref"`
	PostedAt     sql.NullTime   `json:"posted_at"`
	ExpiresAt    sql.NullTime   `json:"expires_at"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, createJob,
		arg.Title,
		arg.Slug,
		arg.Summary,
		arg.Description,
		arg.LocationID,
		arg.ContractType,
		arg.WorkPattern,
		arg.SalaryMin,
		arg.SalaryMax,
		arg.Currency,
		arg.Status,
		arg.Source,
		arg.SourceRef,
		arg.PostedAt,
		arg.ExpiresAt,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Summary,
		&i.Description,
		&i.LocationID,
		&i.ContractType,
		&i.WorkPattern,
		&i.SalaryMin,
		&i.SalaryMax,
		&i.Currency,
		&i.Status,
		&i.Source,
		&i.SourceRef,
		&i.PostedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJobById = `-- name: GetJobById :one
SELECT j.id, j.title, j.slug, j.summary, j.description, j.location_id, j.contract_type, j.work_pattern, j.salary_min, j.salary_max, j.currency, j.status, j.source, j.source_ref, j.posted_at, j.expires_at, j.created_at, j.updated_at,
       jl.country,
       jl.region,
       jl.city
FROM jobs j
LEFT JOIN job_locations jl ON jl.id = j.location_id
WHERE j.id = $1
    AND j.status = 'published'
LIMIT 1
`

type GetJobByIdRow struct {
	ID           uuid.UUID      `json:"id"`
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Summary      sql.NullString `json:"summary"`
	Description  string         `json:"description"`
	LocationID   sql.NullInt64  `json:"location_id"`
	ContractType sql.NullString `json:"contract_type"`
	WorkPattern  sql.NullString `json:"work_pattern"`
	SalaryMin    sql.NullInt32  `json:"salary_min"`
	SalaryMax    sql.NullInt32  `json:"salary_max"`
	Currency     sql.NullString `json:"currency"`
	Status       string         `json:"status"`
	Source       sql.NullString `json:"source"`
	SourceRef    sql.NullString `json:"source_ref"`
	PostedAt     sql.NullTime   `json:"posted_at"`
	ExpiresAt    sql.NullTime   `json:"expires_at"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	Country      sql.NullString `json:"country"`
	Region       sql.NullString `json:"region"`
	City         sql.NullString `json:"city"`
}

func (q *Queries) GetJobById(ctx context.Context, id uuid.UUID) (GetJobByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getJobById, id)
	var i GetJobByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Summary,
		&i.Description,
		&i.LocationID,
		&i.ContractType,
		&i.WorkPattern,
		&i.SalaryMin,
		&i.SalaryMax,
		&i.Currency,
		&i.Status,
		&i.Source,
		&i.SourceRef,
		&i.PostedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Country,
		&i.Region,
		&i.City,
	)
	return i, err
}

const getJobBySlug = `-- name: GetJobBySlug :one
SELECT j.id, j.title, j.slug, j.summary, j.description, j.location_id, j.contract_type, j.work_pattern, j.salary_min, j.salary_max, j.currency, j.status, j.source, j.source_ref, j.posted_at, j.expires_at, j.created_at, j.updated_at,
       jl.country,
       jl.region,
       jl.city
FROM jobs j
LEFT JOIN job_locations jl ON jl.id = j.location_id
WHERE j.slug = $1
    AND j.status = 'published'
LIMIT 1
`

type GetJobBySlugRow struct {
	ID           uuid.UUID      `json:"id"`
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Summary      sql.NullString `json:"summary"`
	Description  string         `json:"description"`
	LocationID   sql.NullInt64  `json:"location_id"`
	ContractType sql.NullString `json:"contract_type"`
	WorkPattern  sql.NullString `json:"work_pattern"`
	SalaryMin    sql.NullInt32  `json:"salary_min"`
	SalaryMax    sql.NullInt32  `json:"salary_max"`
	Currency     sql.NullString `json:"currency"`
	Status       string         `json:"status"`
	Source       sql.NullString `json:"source"`
	SourceRef    sql.NullString `json:"source_ref"`
	PostedAt     sql.NullTime   `json:"posted_at"`
	ExpiresAt    sql.NullTime   `json:"expires_at"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	Country      sql.NullString `json:"country"`
	Region       sql.NullString `json:"region"`
	City         sql.NullString `json:"city"`
}

func (q *Queries) GetJobBySlug(ctx context.Context, slug string) (GetJobBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getJobBySlug, slug)
	var i GetJobBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Summary,
		&i.Description,
		&i.LocationID,
		&i.ContractType,
		&i.WorkPattern,
		&i.SalaryMin,
		&i.SalaryMax,
		&i.Currency,
		&i.Status,
		&i.Source,
		&i.SourceRef,
		&i.PostedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Country,
		&i.Region,
		&i.City,
	)
	return i, err
}

const listPublishedJobs = `-- name: ListPublishedJobs :many
SELECT
    j.id,
    j.title,
    j.slug,
    j.summary,
    j.description,
    j.location_id,
    j.contract_type,
    j.work_pattern,
    j.salary_min,
    j.salary_max,
    j.currency,
    j.status,
    j.source,
    j.source_ref,
    j.posted_at,
    j.expires_at,
    j.created_at,
    j.updated_at,
    jl.country,
    jl.region,
    jl.city,
    COUNT(*) OVER() AS total_count
FROM jobs j
LEFT JOIN job_locations jl ON jl.id = j.location_id
WHERE j.status = 'published'
  AND (
        $1::text IS NULL
        OR j.title ILIKE '%' || $1::text || '%'
        OR j.summary ILIKE '%' || $1::text || '%'
        OR jl.city ILIKE '%' || $1::text || '%'
        OR jl.country ILIKE '%' || $1::text || '%'
    )
  AND (
        $2::text[] IS NULL
        OR EXISTS (
            SELECT 1
            FROM unnest($2::text[]) AS value
            WHERE jl.country ILIKE '%' || value || '%'
        )
    )
  AND (
        $3::text[] IS NULL
        OR EXISTS (
            SELECT 1
            FROM unnest($3::text[]) AS value
            WHERE jl.region ILIKE '%' || value || '%'
            OR jl.city ILIKE '%' || value || '%'
        )
    )
  AND (
        $4::text[] IS NULL
        OR j.contract_type = ANY($4::text[])
    )
  AND (
        $5::text[] IS NULL
        OR EXISTS (
            SELECT 1
            FROM unnest($5::text[]) AS cat
            WHERE (
                cat = 'Vet' AND (j.title ILIKE '%Vet%' OR j.title ILIKE '%Surgeon%') AND j.title NOT ILIKE '%Nurse%'
            ) OR (
                cat = 'Nurse' AND (j.title ILIKE '%Nurse%' OR j.title ILIKE '%RVN%' OR j.title ILIKE '%SVN%')
            )
        )
    )
ORDER BY j.posted_at DESC NULLS LAST, j.created_at DESC
LIMIT $7::int OFFSET $6::int
`

type ListPublishedJobsParams struct {
	Search        sql.NullString `json:"search"`
	Countries     []string       `json:"countries"`
	Regions       []string       `json:"regions"`
	ContractTypes []string       `json:"contract_types"`
	Categories    []string       `json:"categories"`
	OffsetRows    int32          `json:"offset_rows"`
	LimitRows     int32          `json:"limit_rows"`
}

type ListPublishedJobsRow struct {
	ID           uuid.UUID      `json:"id"`
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Summary      sql.NullString `json:"summary"`
	Description  string         `json:"description"`
	LocationID   sql.NullInt64  `json:"location_id"`
	ContractType sql.NullString `json:"contract_type"`
	WorkPattern  sql.NullString `json:"work_pattern"`
	SalaryMin    sql.NullInt32  `json:"salary_min"`
	SalaryMax    sql.NullInt32  `json:"salary_max"`
	Currency     sql.NullString `json:"currency"`
	Status       string         `json:"status"`
	Source       sql.NullString `json:"source"`
	SourceRef    sql.NullString `json:"source_ref"`
	PostedAt     sql.NullTime   `json:"posted_at"`
	ExpiresAt    sql.NullTime   `json:"expires_at"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	Country      sql.NullString `json:"country"`
	Region       sql.NullString `json:"region"`
	City         sql.NullString `json:"city"`
	TotalCount   int64          `json:"total_count"`
}

func (q *Queries) ListPublishedJobs(ctx context.Context, arg ListPublishedJobsParams) ([]ListPublishedJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedJobs,
		arg.Search,
		pq.Array(arg.Countries),
		pq.Array(arg.Regions),
		pq.Array(arg.ContractTypes),
		pq.Array(arg.Categories),
		arg.OffsetRows,
		arg.LimitRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPublishedJobsRow
	for rows.Next() {
		var i ListPublishedJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Summary,
			&i.Description,
			&i.LocationID,
			&i.ContractType,
			&i.WorkPattern,
			&i.SalaryMin,
			&i.SalaryMax,
			&i.Currency,
			&i.Status,
			&i.Source,
			&i.SourceRef,
			&i.PostedAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Country,
			&i.Region,
			&i.City,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
